// Copyright (c) 2023 dingodb.com, Inc. All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

import "common.proto";
import "error.proto";
import "store.proto";

package dingodb.pb.index;

option java_package = "io.dingodb.index";
option cc_generic_services = true;

message VectorAddRequest {
  dingodb.pb.store.Context context = 1;
  repeated dingodb.pb.common.VectorWithId vectors = 2;
  bool replace_deleted = 3;
  bool is_update = 4;
}

message VectorAddResponse {
  dingodb.pb.error.Error error = 1;
  // return the execution status of each key
  // key_states[index] = true, add success
  // key_states[index] = false, add failed
  repeated bool key_states = 2;
}

message VectorBatchQueryRequest {
  dingodb.pb.store.Context context = 1;
  repeated int64 vector_ids = 2;
  bool without_vector_data = 3;       // Default false, if true, response without vector data.
  bool without_scalar_data = 4;       // Default false, if true, response without scalar data.
  repeated string selected_keys = 5;  // If without_scalar_data is false, selected_keys is used to select scalar data,
                                      // if this parameter is null, all scalar data will be returned.
  bool without_table_data = 6;        // Default false, if true, response without table data.
}

message VectorBatchQueryResponse {
  dingodb.pb.error.Error error = 1;
  repeated dingodb.pb.common.VectorWithId vectors = 2;
}

message VectorScanQueryRequest {
  dingodb.pb.store.Context context = 1;
  int64 vector_id_start = 2;
  bool is_reverse_scan = 3;
  int64 max_scan_count = 4;  // the max count user want to scan
  int64 vector_id_end = 5;   // the end id of scan, if is_reverse_scan is true, vector_id_end must be less than
                             // vector_id_start, if is_reverse_scan is false, vector_id_end must be greater than
                             // vector_id_start
                             // the real range is [start, end], include start and end
                             // if vector_id_end == 0, scan to the end of the region

  bool without_vector_data = 11;       // Default false, if true, response without vector data.
  bool without_scalar_data = 12;       // Default false, if true, response without scalar data.
  repeated string selected_keys = 13;  // If without_scalar_data is false, selected_keys is used to select scalar data,
                                       // if this parameter is null, all scalar data will be returned.
  bool without_table_data = 14;        // Default false, if true, response without table data.

  // Whether to use scalar filtering.
  bool use_scalar_filter = 20;
  dingodb.pb.common.VectorScalardata scalar_for_filter = 21;
}

message VectorScanQueryResponse {
  dingodb.pb.error.Error error = 1;
  repeated dingodb.pb.common.VectorWithId vectors = 2;
}

message VectorGetRegionMetricsRequest {
  dingodb.pb.store.Context context = 1;
}

message VectorGetRegionMetricsResponse {
  dingodb.pb.error.Error error = 1;
  dingodb.pb.common.VectorIndexMetrics metrics = 2;
}

message VectorSearchRequest {
  dingodb.pb.store.Context context = 1;
  dingodb.pb.common.VectorSearchParameter parameter = 2;
  repeated dingodb.pb.common.VectorWithId vector_with_ids = 3;  // this field is used for batch search
}

message VectorWithDistanceResult {
  repeated dingodb.pb.common.VectorWithDistance vector_with_distances = 1;
}

message VectorSearchResponse {
  dingodb.pb.error.Error error = 1;
  repeated VectorWithDistanceResult batch_results = 2;  // this field is used for batch search
}

message VectorDeleteRequest {
  dingodb.pb.store.Context context = 1;
  repeated int64 ids = 2;
}

message VectorDeleteResponse {
  dingodb.pb.error.Error error = 1;
  // return the execution status of each key
  // key_states[index] = true, delete success
  // key_states[index] = false, key not exist
  repeated bool key_states = 2;
}

message VectorGetBorderIdRequest {
  dingodb.pb.store.Context context = 1;
  bool get_min = 2;  // if true, get min id, else get max id
}

message VectorGetBorderIdResponse {
  dingodb.pb.error.Error error = 1;
  int64 id = 2;
}

enum AlgorithmType {
  ALGORITHM_NONE = 0;
  ALGORITHM_FAISS = 1;
  ALGORITHM_HNSWLIB = 2;
}

message VectorCalcDistanceRequest {
  // which library algorithm to use
  AlgorithmType algorithm_type = 1;

  // must be valid
  dingodb.pb.common.MetricType metric_type = 2;

  // target vector arrays . empty do nothing. no error.
  repeated dingodb.pb.common.Vector op_left_vectors = 3;

  // source vector arrays . empty do nothing. no error.
  repeated dingodb.pb.common.Vector op_right_vectors = 4;

  // whether to return the normalized result.
  bool is_return_normlize = 5;
}

message VectorDistance {
  repeated float internal_distances = 1;
}

message VectorCalcDistanceResponse {
  dingodb.pb.error.Error error = 1;

  // return normalized result if is_return_normlize is true
  repeated dingodb.pb.common.Vector op_left_vectors = 2;

  // return normalized result if is_return_normlize is true
  repeated dingodb.pb.common.Vector op_right_vectors = 3;

  // num distance values = op_left_vectors *  op_right_vectors
  repeated VectorDistance distances = 4;
}

// vector.id > 0: exact query
// vector.id == 0: similarity search with vector.vector
message VectorSearchDebugRequest {
  dingodb.pb.store.Context context = 1;

  dingodb.pb.common.VectorWithId vector = 2;
  dingodb.pb.common.VectorSearchParameter parameter = 3;
  repeated dingodb.pb.common.VectorWithId vector_with_ids = 4;  // this field is used for batch search
}

message VectorSearchDebugResponse {
  dingodb.pb.error.Error error = 1;
  repeated dingodb.pb.common.VectorWithDistance results = 2;
  repeated VectorWithDistanceResult batch_results = 3;  // this field is used for batch search

  // scalar scan time unit  microsecond 10 -6 s
  int64 deserialization_id_time_us = 4;

  // scalar scan time unit  microsecond 10 -6 s
  int64 scan_scalar_time_us = 5;

  // search  vector unit  microsecond 10 -6 s
  int64 search_time_us = 6;
}

message VectorCountRequest {
  dingodb.pb.store.Context context = 1;
  // [vector_id_start, vector_id_end)
  int64 vector_id_start = 2;  // default region range start_key
  int64 vector_id_end = 3;    // default region range end_key, not include
}

message VectorCountResponse {
  dingodb.pb.error.Error error = 1;
  int64 count = 2;
}

message VectorGetParameter {
  // the parameter below is inherited from VectorBatchQueryRequest
  bool without_vector_data = 1;       // Default false, if true, response without vector data.
  bool without_scalar_data = 2;       // Default false, if true, response without scalar data.
  repeated string selected_keys = 3;  // If without_scalar_data is false, selected_keys is used to select scalar data,
                                      // if this parameter is null, all scalar data will be returned.
  bool without_table_data = 4;        // Default false, if true, response without table data.
}

// TxnGet do point-lookup a value for key in the transaction with start_ts
message TxnGetRequest {
  dingodb.pb.store.Context context = 1;
  // the key client want to do get
  // the key is encoded from two int64 using big-endian, the first int64 is the part id, the second
  // int64 is the vector id. The key MUST be 16 bytes.
  bytes key = 2;
  // the start_ts of the get transaction, store will return the value of the key when commit_ts < start_ts
  int64 start_ts = 3;

  VectorGetParameter parameter = 20;
}

message TxnGetResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // A value could not be retrieved due to the state of the database for the
  // requested key.
  // the txn_result is one of the following:
  // 1. LockInfo: Read conflict with key which is locked by another transaction. The client should backoff or cleanup
  // the lock then retry.
  // 2. otherwise, txn_result is empty
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // The vector value associated with the key, if not found, is empty and error is NOT_FOUND
  // dingo-store do not accept NULL value, so if value is NULL, it means the key is not exist
  dingodb.pb.common.VectorWithId vector = 3;
  // True if the key does not exist in the database.
  // bool not_found = 4;
}

// TxnScan fetches values for a range of keys in the transaction with start_ts.
message TxnScanRequest {
  dingodb.pb.store.Context context = 1;
  // prefix start_key end_key with mode
  // the key in range is encoded from two int64 using big-endian, the first int64 is the part id, the second int64 is
  // the vector id. The key MUST be 16 bytes.
  dingodb.pb.common.RangeWithOptions range = 2;

  // The maximum number of results to return.
  uint32 limit = 4;
  // the start_ts of the get transaction, store will return the value of the key when commit_ts < start_ts
  int64 start_ts = 5;
  // Return only the keys found by scanning, not their values.
  bool key_only = 6;
  // For compatibility, when scanning forward, the range to scan is [start_key, end_key), where start_key < end_key;
  // and when scanning backward, it scans [end_key, start_key) in descending order, where end_key < start_key.
  bool is_reverse = 7;  // NOT_IMPLEMENTED

  // Whether to enable operator pushdown, enabled by default (false: means enabled, true: means disabled)
  bool disable_coprocessor = 8;
  // coprocessor
  dingodb.pb.store.Coprocessor coprocessor = 9;

  VectorGetParameter parameter = 20;
}

// TxnScan can be partially success
// if kvs is not null, and has_more is true, means scan is not finished, client should continue to scan from end_key.
// if txn_result is not null, the kvs may not null, client can use kvs as a partial result, and should continue to scan
// after resolve lock.
message TxnScanResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // This txn_result exists when some key is locked but we cannot check locks of
  // all keys. In this case, `kvs` should be empty and the client should redo
  // scanning all the keys after resolving the lock.
  // the txn_result is one of the following:
  // 1. LockInfo: Read conflict with key which is locked by another transaction.
  // 2. otherwise, txn_result is empty
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // vectors is the return value of the scan request
  repeated dingodb.pb.common.VectorWithId vectors = 3;
  // if scan is not finished, has_more is true, otherwise false
  bool has_more = 4;
  // the last iteratered key of this scan response.
  // if end_key is null, means scan do not successfully iterate any key.
  bytes end_key = 5;
}

message Mutation {
  dingodb.pb.store.Op op = 1;
  // the key is encoded from two int64 using big-endian, the first int64 is the part id, the second
  // int64 is the vector id. The key MUST be 16 bytes.
  bytes key = 2;
  dingodb.pb.common.VectorWithId vector = 3;
}

message TxnPrewriteRequest {
  dingodb.pb.store.Context context = 1;
  // The data to be written to the database.
  repeated Mutation mutations = 2;
  // The primary lock of the transaction is setup by client
  bytes primary_lock = 3;
  // Identifies the transaction being written.
  int64 start_ts = 4;
  // the lock's ttl is timestamp in milisecond.
  int64 lock_ttl = 5;
  // the number of keys involved in the transaction
  int64 txn_size = 6;
  // When the transaction involves only one region, it's possible to commit the
  // transaction directly with 1PC protocol.
  bool try_one_pc = 7;
  // The max commit ts is reserved for limiting the commit ts of 1PC, which can be used to avoid inconsistency with
  // schema change. This field is unused now.
  int64 max_commit_ts = 8;
}

message TxnPrewriteResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // for prewrite, txn_result will be one of the following:
  // 1. LockInfo: prewrite meet a lock and can't proceed, the lock is returned
  // 2. WriteConflict: Write conflict with key which is already written after start_ts
  //    2.1 Optimistic: in optimistic transactions.
  //    2.2  PessimisticRetry: a lock acquisition request waits for a lock and awakes, or meets a newer version of data,
  //                           let Executor retry.
  //    2.3 SelfRolledBack: the transaction itself has been rolled back when it tries to prewrite.
  // 3. otherwise, txn_result is empty
  // for success prewrite, txn_result is empty
  // for failure prewrite, txn_result is not empty
  // if txn_result is AlreadyExist, there will be many txn_result, each txn_result is for one key
  // if there is a WriteConflict in txn_result, client should backoff or cleanup the lock then retry
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // if there is PutIfAbsent in mutation, and if there is key conflict, the conflict key will be returned
  repeated dingodb.pb.store.AlreadyExist keys_already_exist = 3;
  // When the transaction is successfully committed with 1PC protocol, this
  // field will be set to the commit ts of the transaction. Otherwise, if dingo-store
  // failed to commit it with 1PC or the transaction is not 1PC, the value will
  // be 0.
  int64 one_pc_commit_ts = 4;
}

message TxnCommitRequest {
  dingodb.pb.store.Context context = 1;
  // The start_ts of the transaction.
  int64 start_ts = 2;
  // The commit_ts of transaction. Must be greater than `start_ts`.
  int64 commit_ts = 3;
  // All keys in the transaction to be committed.
  repeated bytes keys = 4;
}

message TxnCommitResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // the txn_result is one of the following:
  // 1. TxnNotFound: if committing a key but not found its lock, the lock may be cleaned up by gc or resolved by. If
  // committing primary key meet this error, the transaction may be rolled back. If committing secondary key meet this,
  // Executor can think its lock is resolved, and continue to commit.
  // 2. otherwise, txn_result is empty
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // The commit_ts of the transaction.
  int64 commit_ts = 3;
}

// CheckTxnStatusRequest checks the status of a transaction.
// If the transaction is rollbacked/committed, return that result.
// If the TTL of the transaction is exhausted, abort that transaction and inform the caller.
// Otherwise, returns the TTL information for the transaction.
message TxnCheckTxnStatusRequest {
  dingodb.pb.store.Context context = 1;
  // Primary key and lock ts together to locate the primary lock of a transaction.
  bytes primary_key = 2;
  // Starting timestamp of the transaction being checked.
  int64 lock_ts = 3;
  // The start timestamp of the transaction which this request is part of.
  int64 caller_start_ts = 4;
  // The client must specify the current time to dingo-store using this timestamp.
  // It is used to check TTL timeouts. It may be inaccurate.
  int64 current_ts = 5;
}

message TxnCheckTxnStatusResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // the txn_result is one of the following:
  // 1. PrimaryMismatch: CheckTxnStatus is sent to a lock that's not the primary.
  // 2. TxnNotFound: Txn not found when checking txn status.
  // 3. otherwise, txn_result is empty
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // Three kinds of transaction status:
  //   locked: lock_ttl > 0
  //   committed: commit_ts > 0
  //   rollbacked: lock_ttl = 0 && commit_ts = 0
  int64 lock_ttl = 3;
  // if the transaction of the lock is committed, the commit_ts is returned
  int64 commit_ts = 4;
  // The action performed by dingo-store (and why if the action is to rollback).
  dingodb.pb.store.Action action = 5;
  dingodb.pb.store.LockInfo lock_info = 6;
}

// For all keys locked by the transaction identified by `start_ts`, either
// commit or rollback the transaction and unlock the key.
message TxnResolveLockRequest {
  dingodb.pb.store.Context context = 1;
  int64 start_ts = 2;
  // `commit_ts == 0` means the transaction was rolled back.
  // `commit_ts > 0` means the transaction was committed at the given timestamp.
  int64 commit_ts = 3;
  // Only resolve specified keys.
  repeated bytes keys = 4;
}

message TxnResolveLockResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // now the txn_result is not used, maybe used in the future
  dingodb.pb.store.TxnResultInfo txn_result = 2;
}

message TxnBatchGetRequest {
  dingodb.pb.store.Context context = 1;
  repeated bytes keys = 2;
  int64 start_ts = 3;
  VectorGetParameter parameter = 20;
}

message TxnBatchGetResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // This txn_result exists when some key is locked but we cannot check locks of
  // all keys. In this case, `kvs` should be empty and the client should redo
  // batch get all the keys after resolving the lock.
  // the txn_result is one of the following:
  // 1. LockInfo: Read conflict with key which is locked by another transaction. The client should backoff or cleanup
  // the lock then retry.
  // 2. otherwise, txn_result is empty
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // When some key is locked but we cannot check locks of
  // all keys. In this case, `vectors` should be empty and the client should redo
  // batch get all the keys after resolving the lock.
  repeated dingodb.pb.common.VectorWithId vectors = 3;
}

// Rollback a prewritten transaction. This will remove the preliminary data from
// the database, unlock locks, and leave a rollback tombstone.
message TxnBatchRollbackRequest {
  dingodb.pb.store.Context context = 1;
  // Identify the transaction to be rolled back.
  int64 start_ts = 2;
  // The keys to rollback.
  repeated bytes keys = 3;
}

message TxnBatchRollbackResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnResultInfo txn_result = 2;
}

// Scan the database for locks. Used at the start of the GC process to find all
// old locks.
message TxnScanLockRequest {
  dingodb.pb.store.Context context = 1;
  // Returns all locks with a start timestamp before `max_ts`.
  int64 max_ts = 2;
  // Start scanning from this key.
  // the key is encoded from two int64 using big-endian, the first int64 is the part id, the
  // second int64 is the vector id. The key MUST be 16 bytes.
  bytes start_key = 3;
  // The maximum number of locks to return.
  uint32 limit = 4;
  // The exclusive upperbound for scanning.
  bytes end_key = 5;
}

message TxnScanLockResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // Info on all locks found by the scan.
  repeated dingodb.pb.store.LockInfo locks = 3;
}

// Update the lock_ttl of a large transaction to
// prevent it from been killed.
message TxnHeartBeatRequest {
  dingodb.pb.store.Context context = 1;
  // The key of the lock to update.
  bytes primary_lock = 2;
  // Start timestamp of the large transaction.
  int64 start_ts = 3;
  // The new TTL the sender would like.
  // The advise_lock_ttl is the timestamp of milisecond.
  int64 advise_lock_ttl = 4;
}

message TxnHeartBeatResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  // the txn_result is one of the following:
  // 1. PrimaryMismatch: Heartbeat is sent to a lock that's not the primary.
  // 2. TxnNotFound: Txn not found when heartbeat.
  // 3. otherwise, txn_result is empty
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  // The TTL actually set on the requested lock.
  int64 lock_ttl = 3;
}

// Request dingo-store to garbage collect all non-current data older than `safe_point_ts`.
message TxnGcRequest {
  dingodb.pb.store.Context context = 1;
  int64 safe_point_ts = 2;
}

message TxnGcResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnResultInfo txn_result = 2;
}

// Delete a range of data from dingo-store.
// All keys in the range will be deleted permanently regardless of their
// timestamps. This means that deleted keys will not be retrievable by
// specifying an older timestamp.
message TxnDeleteRangeRequest {
  dingodb.pb.store.Context context = 1;
  // the key is encoded from two int64 using big-endian, the first int64 is the part id, the
  // second int64 is the vector id. The key MUST be 16 bytes.
  bytes start_key = 2;
  // the key is encoded from two int64 using big-endian, the first int64 is the part id, the
  // second int64 is the vector id. The key MUST be 16 bytes.
  bytes end_key = 3;
}

message TxnDeleteRangeResponse {
  // error code
  dingodb.pb.error.Error error = 1;
}

message TxnDumpRequest {
  dingodb.pb.store.Context context = 1;
  // the range is [start_key, end_key)
  bytes start_key = 2;
  bytes end_key = 3;
  // the range is [start_ts, end_ts)
  // if start_ts == 0, means start from the beginning
  // if int64_MAX, means end to the end
  int64 start_ts = 4;
  int64 end_ts = 5;
}

message TxnDumpResponse {
  // error code
  dingodb.pb.error.Error error = 1;
  dingodb.pb.store.TxnResultInfo txn_result = 2;
  repeated dingodb.pb.store.TxnWriteKey keys = 3;
  repeated dingodb.pb.store.TxnWriteValue values = 4;
  repeated dingodb.pb.store.TxnLockKey lock_keys = 5;
  repeated dingodb.pb.store.TxnLockValue lock_values = 6;
  repeated dingodb.pb.store.TxnDataKey data_keys = 7;
  repeated dingodb.pb.store.TxnDataValue data_values = 8;
}

// message TxnScanBeginRequest {
//   dingodb.pb.store.Context context = 1;

//   // prefix start_key end_key with mode
//   // the key in range MUST be 16 bytes, the key is encoded from two int64 using big-endian, the first int64 is
//   // the part id, the second int64 is the vector id.
//   dingodb.pb.common.RangeWithOptions range = 2;

//   // the start_ts of the get transaction, store will return the value of the key when commit_ts < start_ts
//   int64 start_ts = 3;

//   // The maximum number of requests keys per request
//   // limit = 0 means only scan_id is returned and no data is returned
//   // If max_fetch_cnt > 0, it means to return scan_id and data. Note that in this way, the return will be slower
//   because
//   // the data needs to be prepared For example: max_fetch_cnt = 10000, which means that the maximum number of kv
//   items
//   // in this request is 10000, which is just a suggested value. If the maximum number of kv items in the server is
//   1000,
//   // The data returned each time is only 1000 pieces of data. Note: only the maximum number of kv pairs per request
//   int64 max_fetch_cnt = 4;

//   // is it just to get the key
//   bool key_only = 5;

//   // whether to automatically release resources
//   // after reading all the data, the default is false,
//   // and the default is automatically released
//   bool disable_auto_release = 6;

//   // Whether to enable operator pushdown, enabled by default (false: means enabled, true: means disabled)
//   bool disable_coprocessor = 7;

//   // coprocessor
//   dingodb.pb.store.Coprocessor coprocessor = 8;
// }

// message TxnScanBeginResponse {
//   // error code
//   dingodb.pb.error.Error error = 1;

//   // This txn_result exists when some key is locked but we cannot check locks of
//   // all keys. In this case, `kvs` should be empty and the client should redo
//   // scanning all the keys after resolving the lock.
//   // the txn_result is one of the following:
//   // 1. LockInfo: Read conflict with key which is locked by another transaction.
//   // 2. otherwise, txn_result is empty
//   dingodb.pb.store.TxnResultInfo txn_result = 2;

//   // uniquely identifies this scan
//   bytes scan_id = 3;

//   // return key value pair. if kvs.size == 0 means no data
//   repeated dingodb.pb.common.KeyValue kvs = 4;
// }

// message TxnScanContinueRequest {
//   dingodb.pb.store.Context context = 1;

//   // uniquely identifies this scan
//   bytes scan_id = 2;

//   // The maximum number of requests keys per request
//   // If max_fetch_cnt > 0, it means to return scan_id and data. Note that in this way, the return will be slower
//   because
//   // the data needs to be prepared For example: max_fetch_cnt = 10000, which means that the maximum number of kv
//   items
//   // in this request is 10000, which is just a suggested value. If the maximum number of kv items in the server is
//   1000,
//   // The data returned each time is only 1000 pieces of data. Note: only the maximum number of kv pairs per request
//   int64 max_fetch_cnt = 3;
// }

// message TxnScanContinueResponse {
//   // error code
//   dingodb.pb.error.Error error = 1;

//   // This txn_result exists when some key is locked but we cannot check locks of
//   // all keys. In this case, `kvs` should be empty and the client should redo
//   // scanning all the keys after resolving the lock.
//   // the txn_result is one of the following:
//   // 1. LockInfo: Read conflict with key which is locked by another transaction.
//   // 2. otherwise, txn_result is empty
//   dingodb.pb.store.TxnResultInfo txn_result = 2;

//   // return key value pair. if kvs.size == 0 means no data
//   repeated dingodb.pb.common.KeyValue kvs = 3;
// }

// message TxnScanReleaseRequest {
//   dingodb.pb.store.Context context = 1;

//   // uniquely identifies this scan
//   bytes scan_id = 2;
// }

// message TxnScanReleaseResponse {
//   // error code
//   dingodb.pb.error.Error error = 1;
// }

service IndexService {
  // vector index
  rpc VectorAdd(VectorAddRequest) returns (VectorAddResponse);
  rpc VectorBatchQuery(VectorBatchQueryRequest) returns (VectorBatchQueryResponse);
  rpc VectorSearch(VectorSearchRequest) returns (VectorSearchResponse);
  rpc VectorDelete(VectorDeleteRequest) returns (VectorDeleteResponse);
  rpc VectorGetBorderId(VectorGetBorderIdRequest) returns (VectorGetBorderIdResponse);
  rpc VectorScanQuery(VectorScanQueryRequest) returns (VectorScanQueryResponse);
  rpc VectorGetRegionMetrics(VectorGetRegionMetricsRequest) returns (VectorGetRegionMetricsResponse);
  rpc VectorCalcDistance(VectorCalcDistanceRequest) returns (VectorCalcDistanceResponse);
  rpc VectorCount(VectorCountRequest) returns (VectorCountResponse);

  // debug
  // test  vector search performance
  rpc VectorSearchDebug(VectorSearchDebugRequest) returns (VectorSearchDebugResponse);

  // txn rpcs
  rpc TxnGet(TxnGetRequest) returns (TxnGetResponse);
  rpc TxnScan(TxnScanRequest) returns (TxnScanResponse);
  rpc TxnPrewrite(TxnPrewriteRequest) returns (TxnPrewriteResponse);
  rpc TxnCommit(TxnCommitRequest) returns (TxnCommitResponse);
  rpc TxnCheckTxnStatus(TxnCheckTxnStatusRequest) returns (TxnCheckTxnStatusResponse);
  rpc TxnResolveLock(TxnResolveLockRequest) returns (TxnResolveLockResponse);
  rpc TxnBatchGet(TxnBatchGetRequest) returns (TxnBatchGetResponse);
  rpc TxnBatchRollback(TxnBatchRollbackRequest) returns (TxnBatchRollbackResponse);
  rpc TxnScanLock(TxnScanLockRequest) returns (TxnScanLockResponse);
  rpc TxnHeartBeat(TxnHeartBeatRequest) returns (TxnHeartBeatResponse);
  rpc TxnGc(TxnGcRequest) returns (TxnGcResponse);
  rpc TxnDeleteRange(TxnDeleteRangeRequest) returns (TxnDeleteRangeResponse);
  rpc TxnDump(TxnDumpRequest) returns (TxnDumpResponse);

  // rpc TxnScanBegin(TxnScanBeginRequest) returns (TxnScanBeginResponse);
  // rpc TxnScanContinue(TxnScanContinueRequest) returns (TxnScanContinueResponse);
  // rpc TxnScanRelease(TxnScanReleaseRequest) returns (TxnScanReleaseResponse);
};
