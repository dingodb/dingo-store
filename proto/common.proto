// Copyright (c) 2023 dingodb.com, Inc. All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package dingodb.pb.common;

option java_package = "io.dingodb.common";
option cc_generic_services = true;

enum ClusterRole {
  ILLEGAL = 0;
  COORDINATOR = 1;
  STORE = 2;
  EXECUTOR = 3;
};

enum Engine {
  ENG_ROCKSDB = 0;
  ENG_MEMORY = 1;
  ENG_XDP = 2;
  ENG_RAFT_STORE = 3;
  ENG_COLUMNAR = 4;
};

enum RawEngine { RAW_ENG_ROCKSDB = 0; };

message Location {
  string host = 1;
  int32 port = 2;
}

message Range {
  bytes start_key = 1;
  bytes end_key = 2;
}

// prefix scan
message PrefixScanRange {
  Range range = 1;
  bool with_start = 2;
  bool with_end = 3;
}

message KeyValue {
  bytes key = 1;
  bytes value = 2;
}

enum CoordinatorState {
  COORDINATOR_NEW = 0;
  COORDINATOR_NORMAL = 1;
  COORDINATOR_OFFLINE = 2;
}

enum StoreState {
  STORE_NEW = 0;  // a new store, wait to startup and join raft
  STORE_NORMAL = 1;
  STORE_OFFLINE = 2;  // miss hearteat
}

enum StoreInState {
  STORE_IN = 0;   // can replicate data to this store
  STORE_OUT = 1;  // cant not replicate data to this store
}

enum ExecutorState {
  EXECUTOR_NORMAL = 0;
  EXECUTOR_NEW = 1;      // a new store, wait to startup and join raft
  EXECUTOR_OFFLINE = 2;  // miss hearteat
}

enum RegionState {
  REGION_NORMAL = 0;

  REGION_NEW = 1;  // create new region

  REGION_DEGRADED = 2;     // region has less than 3 peer
  REGION_UNAVAILABLE = 3;  // region has no leader elected

  REGION_EXPAND = 4;     // start to expand
  REGION_EXPANDING = 5;  // leader start to expand region
  REGION_EXPANDED = 6;   // new peer joined raft

  REGION_SHRINK = 7;      // start to shrink
  REGION_SHIRINKING = 8;  // leader start to shrink region
  REGION_SHRANK = 9;      // shrink finish, maybe we don't need this state

  REGION_DELETE = 10;    // region need to delete
  REGION_DELETING = 11;  // region is deleting
  REGION_DELETED = 12;   // region is deleted

  REGION_SPLIT = 13;      // region need to split
  REGION_SPLITTING = 14;  // region is splitting
  REGION_SPLITED = 15;    // region is splited (split's past tense is split, not splited, use as a symbol here)

  REGION_MERGE = 16;    // region need to merge
  REGION_MERGING = 17;  // region is mergting
  REGION_MERGED = 18;   // region is merged

  // other state add here
  REGION_ILLEGAL = 20;  // region is not create by coordinator
  REGION_DOWN = 21;     // region is offline
}

// StoreRegionState
// region's state on store, include region's state and raft's state
enum StoreRegionState {
  NEW = 0;        // new region, not join raft
  NORMAL = 1;     // normal
  STANDBY = 2;    // standby, can not serve read/write
  SPLITTING = 3;  // region is spliting to another region
  MERGING = 4;    // region is merging to another region
  DELETING = 5;   // region is deleting
  DELETED = 6;    // region is deleted
  EXPANDING = 7;  // region is adding new peer
  SHRINKING = 8;  // region is removing peer
  ORPHAN = 9;     // region is orphan, need to delete
}

// RegionRaftStatus
// region's raft status
enum RegionRaftStatus {
  HEALTHY = 0;
  LAGGY = 1;
  RECOVERING = 2;
}

message Coordinator {
  uint64 id = 1;
  CoordinatorState state = 2;
  Location location = 3;
  string resource_tag = 4;
}

message CoordinatorMap {
  uint64 epoch = 1;
  repeated Coordinator coordinators = 2;
}

// Executor
//  all fieleds can only be updated by coordinator
message Executor {
  uint64 id = 1;
  uint64 epoch = 2;
  ExecutorState state = 3;
  Location server_location = 4;
  string resource_tag = 5;
  string keyring = 6;
  uint64 create_timestamp = 7;
  uint64 last_seen_timestamp = 8;
}

message ExecutorMap {
  uint64 epoch = 1;
  repeated Executor executors = 2;
}

// Store
message Store {
  uint64 id = 1;                    // only updated by coordinator
  uint64 epoch = 2;                 // only updated by coordinator
  StoreState state = 3;             // only updated by coordinator
  StoreInState in_state = 4;        // only updated by coordinator
  Location server_location = 5;     // store can only update this field in the first heartbeat
  Location raft_location = 6;       // store can only update this field in the first heartbeat
  string resource_tag = 7;          // only updated by coordinator
  string keyring = 8;               // only updated by coordinator
  uint64 create_timestamp = 9;      // only updated by coordinator
  uint64 last_seen_timestamp = 10;  // only updated by coordinator
}

message StoreMap {
  uint64 epoch = 1;
  repeated Store stores = 2;
}

enum PeerRole {
  VOTER = 0;
  LEARNER = 1;
}

message Peer {
  uint64 store_id = 1;
  PeerRole role = 2;
  Location server_location = 3;
  Location raft_location = 4;
}

message Region {
  // store info
  uint64 id = 1;
  uint64 epoch = 2;
  string name = 3;
  RegionState state = 4;
  RegionRaftStatus raft_status = 5;

  int64 leader_store_id = 6;
  repeated Peer peers = 7;
  Range range = 8;

  // meta info
  uint64 schema_id = 9;
  uint64 table_id = 10;

  // other
  uint64 create_timestamp = 11;

  // region definition
  RegionDefinition definition = 12;

  // region metrics
  RegionMetrics metrics = 13;
}

message RegionMap {
  uint64 epoch = 1;
  repeated Region regions = 2;
}

// RegionDefinition
message RegionDefinition {
  // store info
  uint64 id = 1;
  uint64 epoch = 2;
  string name = 3;
  repeated Peer peers = 4;
  Range range = 5;

  // meta info
  uint64 schema_id = 6;
  uint64 table_id = 7;
}

// RaftNodeStatus
// raft node's status
// equal to braft state in raft.h
enum RaftNodeState {
  STATE_NONE = 0;  // this is just a placeholder
  STATE_LEADER = 1;
  STATE_TRANSFERRING = 2;
  STATE_CANDIDATE = 3;
  STATE_FOLLOWER = 4;
  STATE_ERROR = 5;
  STATE_UNINITIALIZED = 6;
  STATE_SHUTTING = 7;
  STATE_SHUTDOWN = 8;
  STATE_END = 9;
}

// RaftPeerStatus
message RaftPeerStatus {
  bool valid = 1;
  bool installing_snapshot = 2;
  uint64 next_index = 3;
  uint64 last_rpc_send_timestamp = 4;
  uint64 flying_append_entries_size = 5;
  uint64 readonly_index = 6;
  uint32 consecutive_error_times = 7;
}

// BRaftStatus
message BRaftStatus {
  RaftNodeState raft_state = 1;
  string peer_id = 11;
  string leader_peer_id = 12;
  bool readonly = 13;
  uint64 term = 14;
  uint64 committed_index = 15;
  uint64 known_applied_index = 16;
  uint64 pending_index = 17;
  uint64 pending_queue_size = 18;
  uint64 applying_index = 19;
  uint64 first_index = 20;
  uint64 last_index = 21;
  uint64 disk_index = 22;

  map<string, RaftPeerStatus> stable_followers = 23;
  map<string, RaftPeerStatus> unstable_followers = 24;
}

// RegionMetrics
message RegionMetrics {
  uint64 id = 1;
  uint64 leader_store_id = 2;               // leader store id
  StoreRegionState store_region_state = 3;  // region state defined by store
  BRaftStatus braft_status = 4;             // region braft status defined by store
  RegionDefinition region_definition = 5;   // region definition

  uint64 row_count = 11;    // row count of this region
  bytes min_key = 12;       // the min key of this region now exist
  bytes max_key = 13;       // the max key of this region now exist
  uint64 region_size = 14;  // the bytes size of this region
}

// StoreMetrics
message StoreMetrics {
  uint64 id = 1;              // store id
  uint64 total_capacity = 2;  // total capacity of this store
  uint64 free_capacity = 3;   // free capacity of this store

  // the key of the map is region_id,  the value is RegionMetrics
  // this map contains all region's metrics include follower on this store
  map<uint64, dingodb.pb.common.RegionMetrics> region_metrics_map = 4;
}
